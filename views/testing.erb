<% @title = 'Testing' %>

<h1>
  Testing
</h1>

<p>
  Testing browser applications can be very easy or very hard, depending on your architectural choices. That's so because there are too many external moving parts involved in running a browser app, and the way we seem to have settled on doing it is by applying a whole browser engine to it. Fact is, when you test interactions such  clicks/taps and such, there's no other way to do it. And therein lies the trick: keeping user interactions and the DOM as detached from the app's logic as possible.
</p>

<p>
  Data-binding — available out of the box in Ember or Angular, and through libraries for Backbone — tends to make testing a lot easier in that regard because you're effectively delegating all DOM interactions to it, and it consequently allows you to test the logic alone and assume all information will be reflected in the DOM correctly.
</p>

<p>
  This won't be covered here, though. If you followed the tips given thus far in this booklet, your apps should be fairly detached from the DOM anyway. The lot of the logic behind it will be testable minus your views' <code>render</code> method. For that, you will need to drop to browser testing. The upside is those tests will be few, and you can realistically keep the fast feedback cycle of unit tests going during development.
</p>

<p>
  One final word about testing: it's not, and will never be, a recipe for high quality software. The value you get out of it is proportional to your ability to architect software correctly. A tested, yet poorly architected app is further evidenced by its tests passing, leaving you under the illusion it's good quality software when it's not.
</p>

<%= partial :- %>

<p>
  In the interest of saving you time discovering what the good testing tools are, and have you instead invest time in applying them, the following form a great trio.
</p>

<p>
  The best, non-magic testing library is <a href="http://visionmedia.github.io/mocha/">Mocha</a>, period. Mocha won't try to guess how your app works. Your tests will look explicit, so anyone reading a test can immediately understand how something is meant to work, which is the bigger benefit of doing this if you're not alone in maintaining the app.
</p>

<p>
  For asserting, you should look into <a href="https://github.com/LearnBoost/expect.js">expect.js</a>.
</p>

<p>
  For mocking, check out <a href="http://sinonjs.org/">Sinon.JS</a>.
</p>

<%= partial :- %>

<p>
  Test runners come in many shapes and sizes, but they all work the same way: they load core dependencies including the testing library, load the class/module to be tested, set up any mocks if any, then run the testing scripts in that environment.
</p>

<p>
  That's all great, but again, avoid packages that make too many assumptions on your behalf, or end up forcing you to write tests that aren't explicit (e.g.: when it's not obvious how you ended up having access to a library you didn't explicitly load yourself). Following the formula above, you should be able to write tests as simple scripts that you can call using the <code>mocha</code> CLI, and they should run fine. If it's <strong>impossible</strong> to run your tests like that, then try and make it so it does.
</p>

<p>
  The point is you want to stay away from a runner that obscures things. To a degree, there are exceptions to this rule: if you're using Rails, <a href="https://github.com/modeset/teaspoon">teaspoon</a> offers seamless integration with Sprockets, allowing you to use directives such as <code>require</code> inside a test script, so you retain the benefit of being able to load things in the style of a manifest while still keeping the test's dependencies explicitly declared.
</p>

<%= partial :- %>

<p>
  Say we have a <code>FormView</code> view, whose purpose is to capture input from a form and create or edit a <code>Book</code> model. We know this view will need to capture the form <code>submit</code> event, pull out the values from each field and instance a new model (or set the existing one) with the attributes set to the values in the form.
</p>

<pre class="language-coffeescript"><code>class FormView extends Backbone.View
  template: JST['books/form']
  events:
    'submit form': 'submitForm'

  initialize: (options = {}) ->
    @model = @model ? options.model

  submitForm: (event) ->
    event.preventDefault()
    @model.set
      name: @$el.find('.name').val(),
      description: @$el.find('.description').val()
    @collection.add @model
    @model.save()</code></pre>

<p>
  The above works, so it <strong>seems</strong> correct. But there's a big problem here: there's no way to verify this works without an actual form element existing, and for that matter, without this view having been rendered. We need to isolate the model creation logic so it can be tested separately. As an aside, this is an excellent example of code that passes tests, but it is, nevertheless, a bad idea.
</p>

<pre class="language-coffeescript"><code>class FormView extends Backbone.View
  template: JST['books/form']
  events:
    'submit form': 'submitForm'

  initialize: (options = {}) ->
    @model = @model ? options.model

  submitForm: (event) ->
    event.preventDefault()
    @createOrUpdateModel
      name: @$el.find('.name').val(),
      description: @$el.find('.description').val()

  createOrUpdateModel: (attributes) ->
    @model.set attributes
    @collection.add @model
    @model.save()</code></pre>

<p>
  You can now test the feature like this:
</p>

<pre class="language-coffeescript"><code># FormView tests
# ============
#
# Run using:
#
# $ NODE_PATH=app/assets/javascripts mocha --compilers coffee:coffee-script \
#     test/javascripts/views/form-view.coffee

$        = require 'jquery'
Backbone = require 'backbone'
FormView = require 'views/form-view'

# Backbone.$ will be undefined unless you assign it.
Backbone.$ = $

describe 'FormView', ->
  it "creates a model and adds to its collection when none is passed", ->
    view = new FormView
    view.createOrUpdateModel {}
    expect(view.collection.length).to.be 1

  it "updates its model with the parameters passed", ->
    view = new FormView model: (new Backbone.Model)
    view.createOrUpdateModel name: 'foo'
    expect(view.model.get 'name').to.be 'foo'</code></pre>

<p>
  In short, the callback methods in the <code>events</code> object — originated from user interactions — aren't tested here. The callbacks will never contain logic beyond handling the interaction itself, and will instead refer to other methods that take simple data structures as parameters, which constitute the class/module's real API.
</p>

<p>
  And when you write tests for those interactions through browser testing, you can restrict the assertions to checking whether certain API methods were called.
</p>
